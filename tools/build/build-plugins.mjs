#!/usr/bin/env bun
/**
 * build-plugins.mjs
 *
 * Auto-generates src/plugins/index.ts by scanning the plugins directory.
 * This eliminates the need to manually import plugins in gamemode scripts.
 *
 * Usage: bun tools/build/build-plugins.mjs
 *
 * Algorithm:
 * 1. Scan src/plugins/ for directories containing index.ts
 * 2. Convert folder names (kebab-case) to camelCase variable names
 * 3. Generate import statements for each plugin's create function
 * 4. Export an array of plugin metadata (name, create function)
 * 5. Generate a type union of all plugin types
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

// ═══════════════════════════════════════════════════════════════════════════
// Configuration
// ═══════════════════════════════════════════════════════════════════════════

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PLUGINS_DIR = path.join(__dirname, "../../src/plugins");
const OUTPUT_FILE = path.join(PLUGINS_DIR, "index.ts");

// ═══════════════════════════════════════════════════════════════════════════
// Helper Functions
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Convert kebab-case to camelCase
 * Example: "example-plugin" → "examplePlugin"
 */
function kebabToCamel(str) {
  return str.replace(/-./g, (match) => match[1].toUpperCase());
}

/**
 * Convert kebab-case to PascalCase
 * Example: "example-plugin" → "ExamplePlugin"
 */
function kebabToPascal(str) {
  const camel = kebabToCamel(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

/**
 * Check if a directory contains an index.ts file
 */
function hasIndexFile(dirPath) {
  const indexPath = path.join(dirPath, "index.ts");
  return fs.existsSync(indexPath);
}

/**
 * Discover all plugin directories
 */
function discoverPlugins() {
  if (!fs.existsSync(PLUGINS_DIR)) {
    console.error(`Plugins directory not found: ${PLUGINS_DIR}`);
    process.exit(1);
  }

  const entries = fs.readdirSync(PLUGINS_DIR, { withFileTypes: true });

  const plugins = entries
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name)
    .filter((name) => {
      const dirPath = path.join(PLUGINS_DIR, name);
      return hasIndexFile(dirPath);
    })
    .sort(); // Alphabetical order for consistency

  return plugins;
}

// ═══════════════════════════════════════════════════════════════════════════
// Code Generation
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Generate the plugins index.ts file
 */
function generatePluginsIndex(pluginNames) {
  if (pluginNames.length === 0) {
    console.warn("No plugins found in plugins directory");
    return `// No plugins found\nexport const plugins = [];\n`;
  }

  let code = "";

  // Header comment
  code += `/**\n`;
  code += ` * THIS FILE IS AUTO-GENERATED BY build-plugins.mjs\n`;
  code += ` * DO NOT EDIT MANUALLY - Your changes will be overwritten\n`;
  code += ` *\n`;
  code += ` * To add a new plugin:\n`;
  code += ` * 1. Create a new directory in src/plugins/\n`;
  code += ` * 2. Add an index.ts file with a create function and type export\n`;
  code += ` * 3. Run: bun run build\n`;
  code += ` *\n`;
  code += ` * Generated on: ${new Date().toISOString()}\n`;
  code += ` */\n\n`;

  // Import statements
  // Import everything from each plugin module and let TypeScript infer types
  pluginNames.forEach((folderName) => {
    code += `import * as ${kebabToCamel(folderName)}Module from "./${folderName}";\n`;
  });

  code += "\n";

  // Export plugins array
  code += `/**\n`;
  code += ` * Array of all discovered plugins with their metadata\n`;
  code += ` */\n`;
  code += `export const plugins = [\n`;

  pluginNames.forEach((folderName) => {
    const camelName = kebabToCamel(folderName);
    const pascalName = kebabToPascal(folderName);
    const moduleName = `${camelName}Module`;
    const createFnName = `create${pascalName}`;

    code += `  { name: "${camelName}", create: ${moduleName}.${createFnName} },\n`;
  });

  code += `] as const;\n\n`;

  // Export type union
  code += `/**\n`;
  code += ` * Union type of all plugin instances\n`;
  code += ` */\n`;
  code += `export type Plugin = `;

  pluginNames.forEach((folderName, index) => {
    const camelName = kebabToCamel(folderName);
    const pascalName = kebabToPascal(folderName);
    const moduleName = `${camelName}Module`;

    // Use ReturnType to infer the plugin type from the create function
    code += `ReturnType<typeof ${moduleName}.create${pascalName}>`;
    if (index < pluginNames.length - 1) {
      code += " | ";
    }
  });

  code += ";\n";

  return code;
}

// ═══════════════════════════════════════════════════════════════════════════
// Main Execution
// ═══════════════════════════════════════════════════════════════════════════

function main() {
  console.log("Scanning for plugins...");

  const plugins = discoverPlugins();

  console.log(`Found ${plugins.length} plugin(s):`);
  plugins.forEach((name) => console.log(`   - ${name}`));

  console.log("\nGenerating plugins/index.ts...");

  const code = generatePluginsIndex(plugins);

  fs.writeFileSync(OUTPUT_FILE, code, "utf8");

  console.log(`Successfully generated: ${OUTPUT_FILE}`);
  console.log("");
}

// Run the script
try {
  main();
} catch (error) {
  console.error("Error generating plugins index:", error);
  process.exit(1);
}
